<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Race Game â€“ IA Autoplay</title>

<style>
body{
  margin:0;
  background:#0b1020;
  font-family:system-ui,Segoe UI,Roboto,Arial;
  display:flex;
  justify-content:center;
  align-items:center;
  min-height:100vh;
  color:#e8eeff;
}
.wrap{width:520px}
canvas{
  width:100%;
  background:#111a33;
  border-radius:14px;
  display:block;
}
.hud{
  display:flex;
  justify-content:space-between;
  margin-bottom:8px;
  font-weight:600;
}
</style>
</head>

<body>
<div class="wrap">
  <div class="hud">
    <div>Pontos: <span id="score">0</span></div>
    <div>Vel: <span id="speed">0</span></div>
    <div>Ultrap.: <span id="passes">0</span></div>
  </div>
  <canvas id="game" width="480" height="800"></canvas>
</div>

<script>
/* ========= CONFIG ========= */
const AUTO_PLAY = true;
const LANES = 3;

/* ========= CANVAS ========= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

/* ========= HUD ========= */
const elScore = document.getElementById("score");
const elSpeed = document.getElementById("speed");
const elPasses = document.getElementById("passes");

/* ========= UTIL ========= */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;

/* ========= ROAD ========= */
const road={
  x:W/2,
  width:W*0.65
};

/* ========= PLAYER ========= */
const player={
  x:road.x,
  y:H*0.78,
  w:42,
  h:76,
  vx:0
};

/* ========= STATE ========= */
const state={
  t:0,
  speed:520,
  speedTarget:520,
  difficulty:1,
  score:0,
  passes:0,
  spawnTimer:0,
  spawnEvery:0.9
};

const enemies=[];
const coins=[];

/* ========= RNG ========= */
function rand(){return Math.random();}

/* ========= LANES ========= */
function laneCenter(i){
  const left=road.x-road.width/2;
  const laneW=road.width/LANES;
  return left+laneW*(i+0.5);
}
function laneIndex(x){
  const left=road.x-road.width/2;
  const laneW=road.width/LANES;
  return clamp(Math.floor((x-left)/laneW),0,LANES-1);
}

/* ========= SPAWN ========= */
function spawnEnemy(){
  const lane=Math.floor(rand()*LANES);
  enemies.push({
    x:laneCenter(lane),
    y:-100,
    w:42,
    h:74,
    vy:state.speed*(0.55+rand()*0.25),
    passed:false
  });
}

/* ========= IA ========= */
function aiDecision(){
  const lookAhead=300;
  const risk=[0,0,0];

  for(const e of enemies){
    if(e.y<player.y && e.y>player.y-lookAhead){
      const l=laneIndex(e.x);
      const d=player.y-e.y;
      risk[l]+=1/(d*d);
    }
  }

  let bestLane=0;
  let minRisk=risk[0];
  for(let i=1;i<LANES;i++){
    if(risk[i]<minRisk){
      minRisk=risk[i];
      bestLane=i;
    }
  }

  return laneCenter(bestLane);
}

/* ========= LOOP ========= */
let last=performance.now();
requestAnimationFrame(loop);

function loop(now){
  const dt=Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ========= UPDATE ========= */
function update(dt){
  state.t+=dt;
  state.difficulty=1+state.t/18;
  state.spawnEvery=clamp(0.9-(state.difficulty-1)*0.08,0.45,0.9);

  state.speedTarget=520+(state.difficulty-1)*120;
  state.speed=lerp(state.speed,state.speedTarget,0.06);

  /* --- IA MOVE --- */
  let targetX=player.x;
  if(AUTO_PLAY){
    targetX=aiDecision();
  }

  const dx=targetX-player.x;
  player.vx+=dx*6*dt;
  player.vx*=0.85;
  player.x+=player.vx*dt;

  const minX=road.x-road.width/2+player.w/2;
  const maxX=road.x+road.width/2-player.w/2;
  player.x=clamp(player.x,minX,maxX);

  /* --- SPAWN --- */
  state.spawnTimer+=dt;
  if(state.spawnTimer>state.spawnEvery){
    state.spawnTimer=0;
    spawnEnemy();
  }

  /* --- ENEMIES --- */
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    e.y+=e.vy*dt;

    if(!e.passed && e.y>player.y){
      e.passed=true;
      state.passes++;
      state.score+=120;
    }

    if(
      Math.abs(e.x-player.x)<(e.w+player.w)/2 &&
      Math.abs(e.y-player.y)<(e.h+player.h)/2
    ){
      // reinicia corretamente
      enemies.length=0;
      state.score=0;
      state.passes=0;
      break;
    }

    if(e.y>H+100) enemies.splice(i,1);
  }

  state.score+=state.speed*dt*0.1;

  elScore.textContent=state.score|0;
  elSpeed.textContent=Math.round(state.speed/10);
  elPasses.textContent=state.passes;
}

/* ========= DRAW ========= */
function draw(){
  ctx.clearRect(0,0,W,H);

  ctx.fillStyle="#1b2a62";
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle="#0b0f1c";
  ctx.fillRect(road.x-road.width/2,0,road.width,H);

  ctx.setLineDash([24,18]);
  ctx.strokeStyle="rgba(255,255,255,0.2)";
  ctx.lineWidth=4;
  for(let i=1;i<LANES;i++){
    const x=road.x-road.width/2+(road.width/LANES)*i;
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,H);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  for(const e of enemies){
    ctx.fillStyle="#ff5a7a";
    ctx.fillRect(e.x-e.w/2,e.y-e.h/2,e.w,e.h);
  }

  ctx.fillStyle="#4de3a5";
  ctx.fillRect(player.x-player.w/2,player.y-player.h/2,player.w,player.h);
}
</script>
</body>
</html>
