<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Race Game â€“ Autoplay</title>

  <style>
    body{
      margin:0;
      background:#0b1020;
      color:#e8eeff;
      font-family:system-ui,Segoe UI,Roboto,Arial;
      display:flex;
      justify-content:center;
      align-items:center;
      min-height:100vh;
    }
    .wrap{width:520px}
    canvas{
      width:100%;
      background:#111a33;
      border-radius:12px;
      display:block;
    }
    .hud{
      display:flex;
      justify-content:space-between;
      margin-bottom:8px;
      font-weight:600;
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="hud">
    <div>Pontos: <span id="score">0</span></div>
    <div>Vel: <span id="speed">0</span></div>
    <div>Ultrap.: <span id="passes">0</span></div>
  </div>
  <canvas id="game" width="480" height="800"></canvas>
</div>

<script>
/* ================= CONFIG ================= */
const AUTO_PLAY = true;   // <<< IA LIGADA
const LANES = 3;

/* ================= CANVAS ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

/* ================= HUD ================= */
const elScore = document.getElementById("score");
const elSpeed = document.getElementById("speed");
const elPasses = document.getElementById("passes");

/* ================= UTIL ================= */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;

/* ================= ROAD ================= */
const road = {
  x: W/2,
  width: W*0.65
};

/* ================= PLAYER ================= */
const player = {
  x: road.x,
  y: H*0.78,
  w: 42,
  h: 76,
  vx: 0
};

/* ================= STATE ================= */
const state = {
  t:0,
  speed:520,
  speedTarget:520,
  difficulty:1,
  score:0,
  passes:0,
  spawnTimer:0,
  spawnEvery:0.9,
  rng:Math.random()*1e9|0
};

/* ================= OBJECTS ================= */
const enemies=[];
const coins=[];

/* ================= RNG ================= */
function rand(){
  state.rng = (1664525*state.rng + 1013904223)>>>0;
  return state.rng/4294967296;
}

/* ================= LANES ================= */
function laneCenter(i){
  const left = road.x-road.width/2;
  const laneW = road.width/LANES;
  return left+laneW*(i+0.5);
}
function laneIndex(x){
  const left = road.x-road.width/2;
  const laneW = road.width/LANES;
  return clamp(Math.floor((x-left)/laneW),0,LANES-1);
}

/* ================= SPAWN ================= */
function spawnEnemy(){
  const lane = Math.floor(rand()*LANES);
  enemies.push({
    x: laneCenter(lane),
    y: -100,
    w:42,
    h:74,
    vy: state.speed*(0.6+rand()*0.25),
    passed:false
  });
  if(rand()<0.3){
    coins.push({
      x: laneCenter(lane)+(rand()-0.5)*30,
      y:-160,
      r:10,
      vy:state.speed*0.55,
      taken:false
    });
  }
}

/* ================= AUTOPLAY IA ================= */
function aiDecision(){
  const look = 260;
  const danger=[0,0,0];
  const bonus=[0,0,0];

  for(const e of enemies){
    if(e.y<player.y && e.y>player.y-look){
      const l=laneIndex(e.x);
      danger[l]+=1/(player.y-e.y);
    }
  }
  for(const c of coins){
    if(!c.taken && c.y<player.y && c.y>player.y-look){
      bonus[laneIndex(c.x)] += 0.3;
    }
  }
  let bestLane=laneIndex(player.x);
  let bestScore=danger[bestLane]-bonus[bestLane];

  for(let i=0;i<LANES;i++){
    const s=danger[i]-bonus[i];
    if(s<bestScore){bestScore=s;bestLane=i;}
  }
  return {
    targetX: laneCenter(bestLane),
    boost: bestScore<0.4
  };
}

/* ================= LOOP ================= */
let last=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ================= UPDATE ================= */
function update(dt){
  state.t+=dt;
  state.difficulty=1+state.t/20;
  state.spawnEvery=clamp(0.9-(state.difficulty-1)*0.08,0.4,0.9);
  state.speedTarget=520+(state.difficulty-1)*120;
  state.speed=lerp(state.speed,state.speedTarget,0.05);

  let dir=0;
  let boost=false;

  if(AUTO_PLAY){
    const ai=aiDecision();
    const dx=ai.targetX-player.x;
    if(Math.abs(dx)>6) dir=dx>0?1:-1;
    boost=ai.boost;
  }

  player.vx+=dir*2100*dt;
  player.vx*=0.86;
  player.x+=player.vx*dt;

  const minX=road.x-road.width/2+player.w/2;
  const maxX=road.x+road.width/2-player.w/2;
  player.x=clamp(player.x,minX,maxX);

  state.spawnTimer+=dt;
  if(state.spawnTimer>state.spawnEvery){
    state.spawnTimer=0;
    spawnEnemy();
  }

  for(const e of enemies){
    e.y+=e.vy*dt;
    if(!e.passed && e.y>player.y){
      e.passed=true;
      state.passes++;
      state.score+=120;
    }
    if(Math.abs(e.x-player.x)<(e.w+player.w)/2 &&
       Math.abs(e.y-player.y)<(e.h+player.h)/2){
      enemies.length=0;
      coins.length=0;
    }
  }

  for(const c of coins){
    c.y+=c.vy*dt;
    if(!c.taken){
      const dx=c.x-player.x;
      const dy=c.y-player.y;
      if(dx*dx+dy*dy<(c.r+18)**2){
        c.taken=true;
        state.score+=250;
      }
    }
  }

  state.score+=state.speed*dt*0.1;

  elScore.textContent=state.score|0;
  elSpeed.textContent=Math.round(state.speed/10);
  elPasses.textContent=state.passes;
}

/* ================= DRAW ================= */
function draw(){
  ctx.clearRect(0,0,W,H);

  ctx.fillStyle="#1b2a62";
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle="#0b0f1c";
  ctx.fillRect(road.x-road.width/2,0,road.width,H);

  ctx.setLineDash([24,18]);
  ctx.strokeStyle="rgba(255,255,255,0.2)";
  ctx.lineWidth=4;
  for(let i=1;i<LANES;i++){
    const x=road.x-road.width/2+(road.width/LANES)*i;
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,H);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  for(const c of coins){
    if(!c.taken){
      ctx.fillStyle="#ffd666";
      ctx.beginPath();
      ctx.arc(c.x,c.y,c.r,0,Math.PI*2);
      ctx.fill();
    }
  }

  for(const e of enemies){
    ctx.fillStyle="#ff5a7a";
    ctx.fillRect(e.x-e.w/2,e.y-e.h/2,e.w,e.h);
  }

  ctx.fillStyle="#4de3a5";
  ctx.fillRect(player.x-player.w/2,player.y-player.h/2,player.w,player.h);
}
</script>
</body>
</html>
